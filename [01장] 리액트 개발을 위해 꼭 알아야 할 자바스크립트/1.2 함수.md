# 1.2 함수
## 1.2.1 함수란 무엇인가?
- 자바스크립트에서 함수란 작업을 수행하거나 값을 계산하는 등의 과정을 표현하고, 이를 하나의 블록으로 감싸서 실행 단위로 만들어 놓은 것을 의미한다.

## 1.2.2 함수를 정의하는 방법들
### 함수 선언문
```ts
function add(a, b) {
  return a+b;
}
```
### 함수 표현식
- 함수 표현식에 대해 알아보기 전에 '일급 객체'라는 개념을 알고 있어야 한다.
- 프로그래밍 세계에서 일급 객체란 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 의미한다.
- 따라서 함수는 다른 함수의 매개변수가 될 수도 있고, 반환값이 될 수도 있으며 할당도 가능하다.
```ts
const sum = function (a, b) {
  return a + b;
}

sum(10, 24); // 34
```

### 함수 표현식과 선언 식의 차이
- 두 가지 방식의 가장 큰 차이는 호이스팅(hoisting) 여부다.
```ts
hello() // hello

function hello() {
  console.log('hello');
}

hello(); // hello
```

### 화살표 함수
- ES6에서 새롭게 추가된 함수 생성 방식으로, function이라는 키워드 대신 =>라는 화살표를 활용해서 함수를 만든다.
```tsx
const add = (a, b) => {
  return a+b;
}

const add = (a,b) => a+b;
```
- 화살표 함수는 앞서 언급한 함수 생성 방식과 몇 가지 큰 차이점이 있다.
- 먼저 화살표 함수에서는 constructor를 사용할 수 없다. 즉, 생성자 함수로 화살표 함수를 사용하는 것은 불가능하다.

```ts
const Car = (name) => {
  this.name = name;
}

// Uncaught TypeError: Car is not a constructor
const myCar = new Car('하이');
```
- 그리고 화살표 함수에서는 arguments가 존재하지 않는다.
```md
arguments?

- JavaScript에서 arguments는 함수에 전달된 인자들을 포함하는 유사 배열 객체이다.
- 함수 내부에서 사용하면, 그 함수로 전달된 모든 인자를 참조할 수 있다.

```ts
function exampleFunction() {
    console.log(arguments[0]);  // 첫 번째 인자 출력
    console.log(arguments.length);  // 인자의 수 출력
}

exampleFunction(10, 20, 30);  // 출력: 10, 3
```

```ts
const hello() {
  console.log(arguments);
}

// Arguments(3) [1, 2, 3, callee: f, symbol(Symbol.iterator): f]
hello(1,2,3);

const hi = () => {
  console.log(arguemnts)
}

// Uncaught ReferenceError: arguments is not defined
hi(1,2,3);
```

- 화살표 함수와 일반 함수의 가장 큰 차이점은 this 바인딩이다.
- this는 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값이다.
- this는 화살표 함수 이전까지는 함수를 정의할 때 결정되는 것이 아니라, 함수가 어떻게 호출되느냐에 따라 동적으로 결정된다.
- 만약 함수가 일반 함수로서 호출된다면, 그 내부의 this는 전역 객체를 가리키게 된다.
#### 전역 컨텍스트에서의 함수 호출
```ts
function showThis() {
  console.log(this);
}

showThis(); // 브라우저에서는 window 객체를 출력, Node.js에서는 global 객체를 출력
```

#### 객체의 메소드로서 함수 호출
```ts
const myObject = {
  name: "ChatGPT",
  showThis: function() {
    console.log(this.name);
  }
};

myObject.showThis(); // "ChatGPT"를 출력
```

#### 화살표 함수의 사용
- 화살표 함수에서는 this가 다르게 동작한다.
- 화살표 함수는 자신을 감싸는 외부 함수의 this 값을 상속받는다.
- 따라서 화살표 함수에서는 this가 동적으로 결정되지 않고, 정의된 시점의 컨텍스트에 바인딩된다.
```ts
const myObject = {
  name: "ChatGPT",
  showThis: () => {
    console.log(this.name); // 여기서 this는 상위 스코프의 this를 가리킨다.
  }
};

myObject.showThis(); // 브라우저에서는 아무것도 출력하지 않거나 undefined 출력, 전역 name 변수가 없다면
```

- 정리하자면, 일반 함수에서 this는 함수가 호출된 위치를 참조하고 화살표 함수는 무조건 함수가 선언된 시점의 상위 컨텍스트를 참조한다.

## 1.2.3 다양한 함수 살펴보기
- 함수를 선언하는 방식이 다양한 것처럼 함수를 사용하는 방식에도 여러 가지가 있다.

### 즉시 실행 함수
- IIFE라고도 불리는, 말 그대로 함수를 정의하고 그 순간 즉시 실행되는 함수를 의미한다.
- 단 한 번만 호출되고, 다시금 호출할 수 없는 함수다.
```ts
(function (a,b) {
  return a+b;
})(10, 24); // 34

((a,b) => {
  return a+b;
})(10, 24); // 34
```
- 한 번 선언하고 호출된 이후부터는 더 이상 재호출이 불가능하므로 일반적으로 즉시 실행 함수에 이름을 붙이지 않는다.
- 이러한 즉시 실행 함수의 특성을 활용하면 글로벌 스코프를 오염시키지 않는 독립적인 함수 스코프를 운용할 수 있다는 장점이 있다.
- 함수의 선언과 실행이 바로 그 자리에서 끝나기 때문에 즉시 실행 함수 내부에 있는 값은 그 함수 내부가 아니고서는 접근이 불가능하기 때문이다.

### 고차 함수
- HOC (Higher Order Function)이라고 한다.
- 함수가 일급 객체라는 특징을 활용하면 함수를 인자로 받거나 결과로 새로운 함수를 반환시킬 수 있는데, 이런 역할을 하는 함수가 고차함수이다.
- 고차 함수란, 다른 함수를 인자로 받거나 함수를 반환하는 함수를 의미한다.
```ts
// 함수를 매개변수로 받는 대표적인 고차 함수, Array.prototype.map
const doubledArray = [1, 2, 3].map((item) => item * 2);

doubledArray; // [2, 4, 6]

// 함수를 반환하는 고차 함수의 예
const add = function (a) {
  // a가 존재하는 클로저를 생성
  return function (b) {
    // b를 인수로 받아 두 합을 반환하는 또 다른 함수를 생성
    return a+b;
  }
}

// 화살표 함수로 사용하면 다음과 같다.
const add = (a) => (b) => a+b;

add(1)(3); // 4
```

## 1.2.4 함수를 만들 때 주의해야 할 사항
- 자바스크립트로 코드를 작성하다 보면 함수를 굉장히 자주 만든다.
- 습관적으로 함수를 만들다 보면 함수 생성과 사용에 있어 중요한 부분을 놓칠 수 있다.
- 함수를 만들기 전에 좋은 함수란 무엇이고 또 함수를 만들 때 무엇을 조심해야 하는지 살펴보자.

### 함수의 부수 효과를 최대한 억제하라
- 함수의 부수 효과란 함수 내의 작동으로 인해 함수가 아닌 함수 외부에 영향을 끼치는 것을 의미한다.
- 이러한 부수 효과가 없는 함수를 순수 함수라 하고, 부수 효과가 존재하는 함수를 비순수 함수라고 한다.
- 즉, 순수 함수는 부수 효과가 없고 언제 어디서나 어떠한 상황에서든 동일한 인수를 받으면 동일한 결과를 반환해야 한다.
- 그리고 이러한 작동 와중에 외부에 어떠한 영향도 미쳐서는 안된다.
```tsx
function PureComponent(props) {
  const {a, b} = props;
  return <div>{a + b}</div>
}
```
- 위의 컴포넌트는 순수 함수 컴포넌트다.
- 웹 애플리케이션을 만드는 과정에서 부수 효과는 피할 수 없는 요소지만, 최소화하는 것이 중요하다.
- 리액트의 관점에서 본다면 부수 효과를 처리하는 훅인 useEffect의 작동을 최소화하는 것이 순수 함수 컴포넌트를 만드는 방법이다.
- useEffect의 사용은 피할 수 없지만 최소한으로 줄임으로써 함수의 역할을 좁히고, 버그를 줄이며, 컴포넌트의 안전성을 높일 수 있다.
- 따라서 자바스크립트 함수에서는 가능한 한 부수 효과를 최소화하고, 함수의 실행과 결과를 최대한 예측 가능하도록 설계해야 한다.
- 예측 가능한 단위의 부수 효과가 작은 함수를 설계하면 개발자와 이를 유지보수하는 또 다른 개발자에게 많은 도움을 준다.

### 가능한 한 함수를 작게 만들어라
- 자바스크립트 개발자들이 프로젝트를 만들 때 사용하는 ESLint에는 max-lines-per-function이라는 규칙이 있다.
- 기본적으로 50줄 이상이 넘어가면 과도하게 커진 함수로 분류한다고 하지만 필수로 50줄을 맞추라는 얘기는 아니다.
- 하나의 함수에서 너무나 많은 일을 하지 않게 하는 것이 중요하다.

### 누구나 이해할 수 있는 이름을 붙여라
